package client;

import edu.umass.cs.nio.AbstractBytePacketDemultiplexer;
import edu.umass.cs.nio.MessageNIOTransport;
import edu.umass.cs.nio.interfaces.NodeConfig;
import edu.umass.cs.nio.nioutils.NIOHeader;
import server.SingleServer;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;

import server.MyDBSingleServer;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
import org.json.JSONObject;


public class MyDBClient extends Client {
    private NodeConfig<String> nodeConfig = null;
    
    // Concurrent Hash Map to store the a unique hashcode for every Callback. 
    static ConcurrentHashMap<Integer, Callback> callbackMap = new ConcurrentHashMap<>();

    public MyDBClient() throws IOException {
    }

    public MyDBClient(NodeConfig<String> nodeConfig) throws IOException {
        super();
        this.nodeConfig = nodeConfig;
    }

    protected void handleResponse(byte[] bytes, NIOHeader header) {
        // If handleResponse receives a JSON response containing the request code, 
        // then the corresponding callback is called.
        try {
            System.out.println(new String(bytes, MyDBSingleServer.DEFAULT_ENCODING));
            String response = new String(bytes, MyDBSingleServer.DEFAULT_ENCODING);
            
            // If valid JSON response then callback is called and response is printed. Else just response is printed. 
            if (checkIfValidJson(response)) {
                System.out.println("response obtained is " + response);
                
                JSONObject json = new JSONObject(response);
                int count = Integer.parseInt(json.getString("counter"));
                String response_text = json.getString("response");

                Callback callback = callbackMap.get(count);
                // callback.handleResponse(bytes, null);
                callback.handleResponse(response_text.getBytes(MyDBSingleServer.DEFAULT_ENCODING), null);

            }
            System.out.println(new String(bytes, MyDBSingleServer.DEFAULT_ENCODING));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public void callbackSend(InetSocketAddress isa, String request, Callback callback) throws IOException 
    {
        // Each callback is assigned a unqiue hashcode and stored in the Concurrent Hash Map callbackMap
        // The key is generated from the callback's hashCode(). 
        // Which according to Java's documentation returns: 
        //"
        // java.lang.Object.hashCode(): Returns a hash code value for the object. 
        // This method is supported for the benefit of hash tables such as those provided by HashMap.
        //"
        try {
            // JSON object will contain request code and the query to be executed by the Server on Cassandra DB.
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("request", request); // Assuming that request contains correct CQL query.
            int count = callback.hashCode(); // Use a unique identifier for each callback generated by java.lang.Object.hashCode()
            System.out.println("COUNT IS " + count);
            jsonObject.put("counter", count); // Prepared JSON to be sent to Server
            callbackMap.put(count, callback); // Stored hashcode, callback in callbackMap
            this.send(isa, jsonObject.toString()); // Sending the JSON object to the server.
        } catch (Exception e) {
            System.out.println("Exception occurred");
            e.printStackTrace();
        }
    }
    
    // Util function to check whether a given string text is JSON formatted or not. 
    public boolean checkIfValidJson(String text) {
        try {
            new JSONObject(text);
        } catch (Exception e) {
            return false;
        }
        return true;
    }
}
